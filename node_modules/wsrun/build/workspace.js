"use strict";
/**
 * Remove me.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.listPkgs = void 0;
const fs = require("fs");
const path = require("path");
const glob = require("glob");
const lodash_1 = require("lodash");
/**
 * Given a path, it returns paths to package.json files of all packages,
 * and the package JSONs themselves.
 */
function listPkgs(wsRoot, globs) {
    // based on yarn v1.18.0 workspace resolution: https://github.com/yarnpkg/yarn/blob/v1.18.0/src/config.js#L794
    const registryFilenames = ['package.json', 'yarn.json'];
    const registryFolders = ['node_modules'];
    const trailingPattern = `/+(${registryFilenames.join('|')})`;
    const ignorePatterns = registryFolders.map(folder => `/${folder}/**/+(${registryFilenames.join('|')})`);
    const pkgJsonPaths = lodash_1.flatMap(globs, (g) => glob.sync(g.replace(/\/?$/, trailingPattern), {
        cwd: wsRoot,
        ignore: ignorePatterns.map(ignorePattern => g.replace(/\/?$/, ignorePattern))
    }));
    const packages = {};
    pkgJsonPaths.forEach(pkgJsonPath => {
        const pkgDir = path.dirname(pkgJsonPath);
        const pkgJson = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));
        if (!pkgJson.name)
            throw new Error(`Package in directory ${pkgDir} has no name in ${path.basename(pkgJsonPath)}`);
        packages[pkgJson.name] = {
            path: path.join(wsRoot, pkgDir),
            json: pkgJson
        };
    });
    return packages;
}
exports.listPkgs = listPkgs;
//# sourceMappingURL=workspace.js.map