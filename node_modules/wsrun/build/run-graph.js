"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunGraph = void 0;
const Bromise = require("bluebird");
const chalk_1 = require("chalk");
const enums_1 = require("./enums");
const lodash_1 = require("lodash");
const cmd_process_1 = require("./cmd-process");
const minimatch = require("minimatch");
const fix_paths_1 = require("./fix-paths");
const console_1 = require("./console");
const jest_changed_files_1 = require("jest-changed-files");
const filter_changed_packages_1 = require("./filter-changed-packages");
const rev_deps_1 = require("./rev-deps");
let mkThroat = require('throat')(Bromise);
let passThrough = f => f();
class Prefixer {
    constructor() {
        this.currentName = '';
        this.prefixer = (basePath, pkg, line) => {
            let l = '';
            if (this.currentName != pkg)
                l += chalk_1.default.bold((this.currentName = pkg)) + '\n';
            l += ' | ' + line; // this.processFilePaths(basePath, line)
            return l;
        };
    }
}
class RunGraph {
    constructor(pkgJsons, opts, pkgPaths) {
        this.pkgJsons = pkgJsons;
        this.opts = opts;
        this.pkgPaths = pkgPaths;
        this.procmap = new Map();
        this.jsonMap = new Map();
        this.runList = new Set();
        this.resultMap = new Map();
        this.throat = passThrough;
        this.pathRewriter = (pkgPath, line) => fix_paths_1.fixPaths(this.opts.workspacePath, pkgPath, line);
        this.globalPrefixer = new Prefixer().prefixer;
        /**
         * Creates or provides the global prefixer. This depends on the collect-logs flag which describes whether the processes should use a shared prefixer.
         */
        this.createOrProvidePrefixerForProcess = () => {
            if (this.opts.addPrefix) {
                if (this.opts.collectLogs) {
                    return new Prefixer().prefixer;
                }
                else {
                    return this.globalPrefixer;
                }
            }
            return undefined;
        };
        this.addRevDeps = (pkgs) => {
            if (this.opts.revRecursive) {
                return rev_deps_1.expandRevDeps(pkgs, this.pkgJsons);
            }
            else {
                return pkgs;
            }
        };
        this.checkResultsAndReport = this.checkResultsAndReport.bind(this);
        pkgJsons.forEach(j => this.jsonMap.set(j.name, j));
        this.children = [];
        // serial always has a concurrency of 1
        if (this.opts.mode === 'serial')
            this.throat = mkThroat(1);
        // max 16 proc unless otherwise specified
        else if (this.opts.mode === 'stages')
            this.throat = mkThroat(opts.concurrency || 16);
        else if (opts.concurrency)
            this.throat = mkThroat(opts.concurrency);
        if (opts.collectLogs)
            this.consoles = new console_1.SerializedConsole(console);
        else
            this.consoles = new console_1.DefaultConsole();
    }
    closeAll() {
        console.log('Stopping', this.children.length, 'active children');
        this.children.forEach(ch => ch.stop());
    }
    lookupOrRun(cmd, pkg) {
        let proc = this.procmap.get(pkg);
        if (proc == null) {
            proc = Bromise.resolve().then(() => this.runOne(cmd, pkg));
            this.procmap.set(pkg, proc);
            return proc;
        }
        return proc;
    }
    allDeps(pkg) {
        let findMyDeps = lodash_1.uniq(Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.devDependencies || {}))).filter(d => this.jsonMap.has(d) && (this.opts.recursive || this.runList.has(d)));
        return findMyDeps;
    }
    detectCycles() {
        let topLevelPkgs = {};
        for (let key of this.jsonMap.keys()) {
            topLevelPkgs[key] = '*';
        }
        let top = { name: '$', dependencies: topLevelPkgs };
        let self = this;
        function deepCycle(json, pathLookup) {
            let newPathLookup = pathLookup.concat([json.name]);
            let index = pathLookup.indexOf(json.name);
            if (index >= 0) {
                return newPathLookup.slice(index);
            }
            let currentDeps = Object.keys(json.dependencies || {}).concat(Object.keys(json.devDependencies || {}));
            for (let name of currentDeps) {
                let d = self.jsonMap.get(name);
                if (!d)
                    continue;
                let res = deepCycle(d, newPathLookup);
                if (res.length)
                    return res;
            }
            return [];
        }
        let res = deepCycle(top, []);
        return res;
    }
    makeCmd(cmd) {
        return [this.opts.bin].concat(cmd);
    }
    runCondition(cmd, pkg) {
        let cmdLine = this.makeCmd(cmd.split(' '));
        let c = this.consoles.create();
        const child = new cmd_process_1.CmdProcess(c, cmdLine, pkg, {
            rejectOnNonZeroExit: false,
            silent: true,
            collectLogs: this.opts.collectLogs,
            prefixer: this.createOrProvidePrefixerForProcess(),
            doneCriteria: this.opts.doneCriteria,
            path: this.pkgPaths[pkg]
        });
        child.finished.then(() => this.consoles.done(c));
        let rres = child.exitCode.then(code => code === 0);
        child.start();
        return rres;
    }
    runOne(cmdArray, pkg) {
        let p = this.jsonMap.get(pkg);
        if (p == null)
            throw new Error('Unknown package: ' + pkg);
        let myDeps = Bromise.all(this.allDeps(p).map(d => this.lookupOrRun(cmdArray, d)));
        return myDeps.then(depsStatuses => {
            this.resultMap.set(pkg, enums_1.ResultSpecialValues.Pending);
            if (this.opts.exclude.indexOf(pkg) >= 0) {
                console.log(chalk_1.default.bold(pkg), 'in exclude list, skipping');
                this.resultMap.set(pkg, enums_1.ResultSpecialValues.Excluded);
                return Bromise.resolve(enums_1.ProcResolution.Excluded);
            }
            if (this.opts.excludeMissing && (!p || !p.scripts || !p.scripts[cmdArray[0]])) {
                console.log(chalk_1.default.bold(pkg), 'has no', cmdArray[0], 'script, skipping missing');
                this.resultMap.set(pkg, enums_1.ResultSpecialValues.MissingScript);
                return Bromise.resolve(enums_1.ProcResolution.Missing);
            }
            let ifCondtition = Bromise.resolve(true);
            if (this.opts.if &&
                (!this.opts.ifDependency || !depsStatuses.find(ds => ds === enums_1.ProcResolution.Normal))) {
                ifCondtition = this.runCondition(this.opts.if, pkg);
            }
            let child = ifCondtition.then(shouldExecute => {
                if (!shouldExecute) {
                    this.resultMap.set(pkg, enums_1.ResultSpecialValues.Excluded);
                    return Bromise.resolve({
                        status: enums_1.ProcResolution.Excluded,
                        process: null
                    });
                }
                let cmdLine = this.makeCmd(cmdArray);
                let c = this.consoles.create();
                const child = new cmd_process_1.CmdProcess(c, cmdLine, pkg, {
                    rejectOnNonZeroExit: this.opts.fastExit,
                    collectLogs: this.opts.collectLogs,
                    prefixer: this.createOrProvidePrefixerForProcess(),
                    pathRewriter: this.opts.rewritePaths ? this.pathRewriter : undefined,
                    doneCriteria: this.opts.doneCriteria,
                    path: this.pkgPaths[pkg]
                });
                child.finished.then(() => this.consoles.done(c));
                child.exitCode.then(code => this.resultMap.set(pkg, code));
                this.children.push(child);
                return Promise.resolve({ status: enums_1.ProcResolution.Normal, process: child });
            });
            return child.then(ch => {
                let processRun = this.throat(() => {
                    if (ch.process) {
                        ch.process.start();
                        return ch.process.finished;
                    }
                    return Bromise.resolve();
                });
                if (this.opts.mode === 'parallel' || !ch.process)
                    return ch.status;
                else
                    return processRun.thenReturn(enums_1.ProcResolution.Normal);
            });
        });
    }
    checkResultsAndReport(cmdLine, pkgs) {
        let cmd = cmdLine.join(' ');
        const pkgsInError = [];
        const pkgsSuccessful = [];
        const pkgsPending = [];
        const pkgsSkipped = [];
        const pkgsMissingScript = [];
        this.resultMap.forEach((result, pkg) => {
            switch (result) {
                case enums_1.ResultSpecialValues.Excluded:
                    pkgsSkipped.push(pkg);
                    break;
                case enums_1.ResultSpecialValues.MissingScript:
                    pkgsMissingScript.push(pkg);
                    break;
                case enums_1.ResultSpecialValues.Pending:
                    pkgsPending.push(pkg);
                    break;
                case 0:
                    pkgsSuccessful.push(pkg);
                    break;
                default:
                    pkgsInError.push(pkg);
                    break;
            }
        });
        if (this.opts.showReport) {
            const formatPkgs = (pgks) => pgks.join(', ');
            const pkgsNotStarted = pkgs.filter(pkg => !this.resultMap.has(pkg));
            console.log(chalk_1.default.bold('\nReport:'));
            if (pkgsInError.length)
                console.log(chalk_1.default.red(`  ${pkgsInError.length} packages finished \`${cmd}\` with error: ${formatPkgs(pkgsInError)}`));
            if (pkgsSuccessful.length)
                console.log(chalk_1.default.green(`  ${pkgsSuccessful.length} packages finished \`${cmd}\` successfully: ${formatPkgs(pkgsSuccessful)}`));
            if (pkgsPending.length)
                console.log(chalk_1.default.white(`  ${pkgsPending.length} packages have been cancelled running \`${cmd}\`: ${formatPkgs(pkgsPending)}`));
            if (pkgsNotStarted.length)
                console.log(chalk_1.default.white(`  ${pkgsNotStarted.length} packages have not started running \`${cmd}\`: ${formatPkgs(pkgsNotStarted)}`));
            if (pkgsMissingScript.length)
                console.log(chalk_1.default.gray(`  ${pkgsMissingScript.length} packages are missing script \`${cmd}\`: ${formatPkgs(pkgsMissingScript)}`));
            if (pkgsSkipped.length)
                console.log(chalk_1.default.gray(`  ${pkgsSkipped.length} packages have been skipped: ${formatPkgs(pkgsSkipped)}`));
            console.log();
        }
        return pkgsInError.length > 0;
    }
    filterByGlobs(pkgs, globs) {
        if (globs && globs.length > 0) {
            pkgs = pkgs.filter(name => globs.some(glob => minimatch(name, glob)));
        }
        return Bromise.resolve(pkgs);
    }
    filterByChangedFiles(pkgs) {
        // if changedSince is defined, filter the packages to contain only changed packages (according to git)
        if (this.opts.changedSince) {
            return jest_changed_files_1.getChangedFilesForRoots([this.opts.workspacePath], {
                changedSince: this.opts.changedSince
            })
                .then(data => {
                if (!data.repos || (data.repos.git.size === 0 && data.repos.hg.size === 0)) {
                    throw new Error("The workspace is not a git/hg repo and it cannot work with 'changedSince'");
                }
                return filter_changed_packages_1.filterChangedPackages([...data.changedFiles], this.pkgPaths, this.opts.workspacePath);
            })
                .then(changedPackages => lodash_1.intersection(pkgs, changedPackages));
        }
        return Promise.resolve(pkgs);
    }
    run(cmd, globs = ['**/*']) {
        return __awaiter(this, void 0, void 0, function* () {
            let pkgs = this.pkgJsons.map(p => p.name);
            pkgs = yield this.filterByGlobs(pkgs, globs).then(pkgs => this.filterByChangedFiles(pkgs).then(pkgs => this.addRevDeps(pkgs)));
            this.runList = new Set(pkgs);
            return (Bromise.all(pkgs.map(pkg => this.lookupOrRun(cmd, pkg)))
                // Wait for any of them to error
                .then(() => Bromise.all(this.children.map(c => c.exitError)))
                // If any of them do, and fastExit is enabled, stop every other
                .catch(_err => this.opts.fastExit && this.closeAll())
                // Wait for the all the processes to finish
                .then(() => Bromise.all(this.children.map(c => c.result)))
                // Generate report
                .then(() => this.checkResultsAndReport(cmd, pkgs)));
        });
    }
}
exports.RunGraph = RunGraph;
//# sourceMappingURL=run-graph.js.map